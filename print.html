<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="book.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="index.html">Home</a></li><li class="chapter-item affix "><li class="part-title">src</li><li class="chapter-item "><a href="src/lib/index.html">❱ lib</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="src/lib/LibBytes.sol/error.TruncateError.html">TruncateError</a></li><li class="chapter-item "><a href="src/lib/LibBytes.sol/library.LibBytes.html">LibBytes</a></li><li class="chapter-item "><a href="src/lib/LibMemCpy.sol/library.LibMemCpy.html">LibMemCpy</a></li><li class="chapter-item "><a href="src/lib/LibMemory.sol/library.LibMemory.html">LibMemory</a></li><li class="chapter-item "><a href="src/lib/LibPointer.sol/type.Pointer.html">Pointer</a></li><li class="chapter-item "><a href="src/lib/LibPointer.sol/library.LibPointer.html">LibPointer</a></li><li class="chapter-item "><a href="src/lib/LibStackPointer.sol/error.UnalignedStackPointer.html">UnalignedStackPointer</a></li><li class="chapter-item "><a href="src/lib/LibStackPointer.sol/library.LibStackPointer.html">LibStackPointer</a></li><li class="chapter-item "><a href="src/lib/LibStackSentinel.sol/error.MissingSentinel.html">MissingSentinel</a></li><li class="chapter-item "><a href="src/lib/LibStackSentinel.sol/type.Sentinel.html">Sentinel</a></li><li class="chapter-item "><a href="src/lib/LibStackSentinel.sol/library.LibStackSentinel.html">LibStackSentinel</a></li><li class="chapter-item "><a href="src/lib/LibUint256Array.sol/error.OutOfBoundsTruncate.html">OutOfBoundsTruncate</a></li><li class="chapter-item "><a href="src/lib/LibUint256Array.sol/library.LibUint256Array.html">LibUint256Array</a></li><li class="chapter-item "><a href="src/lib/LibUint256Matrix.sol/library.LibUint256Matrix.html">LibUint256Matrix</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rainprotocol/rain.solmem" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="libbytes"><a class="header" href="#libbytes">LibBytes</a></h1>
<p>Things we want to do carefully and efficiently with <code>bytes</code> in memory that
Solidity doesn't give us native tools for.</p>
<h2 id="docs"><a class="header" href="#docs">Docs</a></h2>
<p>https://rainprotocol.github.io/sol.lib.bytes</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contents"><a class="header" href="#contents">Contents</a></h1>
<ul>
<li><a href="src/lib/LibBytes.sol/error.TruncateError.html">TruncateError</a></li>
<li><a href="src/lib/LibBytes.sol/library.LibBytes.html">LibBytes</a></li>
<li><a href="src/lib/LibMemCpy.sol/library.LibMemCpy.html">LibMemCpy</a></li>
<li><a href="src/lib/LibMemory.sol/library.LibMemory.html">LibMemory</a></li>
<li><a href="src/lib/LibPointer.sol/type.Pointer.html">Pointer</a></li>
<li><a href="src/lib/LibPointer.sol/library.LibPointer.html">LibPointer</a></li>
<li><a href="src/lib/LibStackPointer.sol/error.UnalignedStackPointer.html">UnalignedStackPointer</a></li>
<li><a href="src/lib/LibStackPointer.sol/library.LibStackPointer.html">LibStackPointer</a></li>
<li><a href="src/lib/LibStackSentinel.sol/error.MissingSentinel.html">MissingSentinel</a></li>
<li><a href="src/lib/LibStackSentinel.sol/type.Sentinel.html">Sentinel</a></li>
<li><a href="src/lib/LibStackSentinel.sol/library.LibStackSentinel.html">LibStackSentinel</a></li>
<li><a href="src/lib/LibUint256Array.sol/error.OutOfBoundsTruncate.html">OutOfBoundsTruncate</a></li>
<li><a href="src/lib/LibUint256Array.sol/library.LibUint256Array.html">LibUint256Array</a></li>
<li><a href="src/lib/LibUint256Matrix.sol/library.LibUint256Matrix.html">LibUint256Matrix</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="truncateerror"><a class="header" href="#truncateerror">TruncateError</a></h1>
<p><a href="https://github.com/rainprotocol/rain.solmem/blob/7b2f04d6e0d7d4573e6b0a17bd9c7b84a7fde05f/src/lib/LibBytes.sol">Git Source</a></p>
<p>Thrown when asked to truncate data to a longer length.</p>
<pre><code class="language-solidity">error TruncateError(uint256 length, uint256 truncate);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libbytes-1"><a class="header" href="#libbytes-1">LibBytes</a></h1>
<p><a href="https://github.com/rainprotocol/rain.solmem/blob/7b2f04d6e0d7d4573e6b0a17bd9c7b84a7fde05f/src/lib/LibBytes.sol">Git Source</a></p>
<p>Tools for working directly with memory in a Solidity compatible way.</p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<h3 id="truncate"><a class="header" href="#truncate">truncate</a></h3>
<p>Truncates bytes of data by mutating its length directly.
Any excess bytes are leaked</p>
<pre><code class="language-solidity">function truncate(bytes memory data, uint256 length) internal pure;
</code></pre>
<h3 id="datapointer"><a class="header" href="#datapointer">dataPointer</a></h3>
<p>Pointer to the data of a bytes array NOT the length prefix.</p>
<pre><code class="language-solidity">function dataPointer(bytes memory data) internal pure returns (Pointer pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>data</code></td><td><code>bytes</code></td><td>Bytes to get the data pointer for.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>Pointer to the data of the bytes in memory.</td></tr>
</tbody></table>
</div>
<h3 id="startpointer"><a class="header" href="#startpointer">startPointer</a></h3>
<p>Pointer to the start of a bytes array (the length prefix).</p>
<pre><code class="language-solidity">function startPointer(bytes memory data) internal pure returns (Pointer pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>data</code></td><td><code>bytes</code></td><td>Bytes to get the pointer to.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>Pointer to the start of the bytes data structure.</td></tr>
</tbody></table>
</div>
<h3 id="enddatapointer"><a class="header" href="#enddatapointer">endDataPointer</a></h3>
<p>Pointer to the end of some bytes.
Note that this pointer MAY NOT BE ALIGNED, i.e. it MAY NOT point to the
start of a multiple of 32, UNLIKE the free memory pointer at 0x40.</p>
<pre><code class="language-solidity">function endDataPointer(bytes memory data) internal pure returns (Pointer pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>data</code></td><td><code>bytes</code></td><td>Bytes to get the pointer to the end of.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>Pointer to the end of the bytes data structure.</td></tr>
</tbody></table>
</div>
<h3 id="endallocatedpointer"><a class="header" href="#endallocatedpointer">endAllocatedPointer</a></h3>
<p>Pointer to the end of the memory allocated for bytes.
The allocator is ALWAYS aligned to whole words, i.e. 32 byte multiples,
for data structures allocated by Solidity. This includes <code>bytes</code> which
means that any time the length of some <code>bytes</code> is NOT a multiple of 32
the alloation will point past the end of the <code>bytes</code> data.
There is no guarantee that the memory region between <code>endDataPointer</code>
and <code>endAllocatedPointer</code> is zeroed out. It is best to think of that
space as leaked garbage.
Almost always, e.g. for the purpose of copying data between regions, you
will want <code>endDataPointer</code> rather than this function.</p>
<pre><code class="language-solidity">function endAllocatedPointer(bytes memory data) internal pure returns (Pointer pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>data</code></td><td><code>bytes</code></td><td>Bytes to get the end of the allocated data region for.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>Pointer to the end of the allocated data region.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="libmemcpy"><a class="header" href="#libmemcpy">LibMemCpy</a></h1>
<p><a href="https://github.com/rainprotocol/rain.solmem/blob/7b2f04d6e0d7d4573e6b0a17bd9c7b84a7fde05f/src/lib/LibMemCpy.sol">Git Source</a></p>
<h2 id="functions-1"><a class="header" href="#functions-1">Functions</a></h2>
<h3 id="unsafecopybytesto"><a class="header" href="#unsafecopybytesto">unsafeCopyBytesTo</a></h3>
<p>Copy an arbitrary number of bytes from one location in memory to another.
As we can only read/write bytes in 32 byte chunks we first have to loop
over 32 byte values to copy then handle any unaligned remaining data. The
remaining data will be appropriately masked with the existing data in the
final chunk so as to not write past the desired length. Note that the
final unaligned write will be more gas intensive than the prior aligned
writes. The writes are completely unsafe, the caller MUST ensure that
sufficient memory is allocated and reading/writing the requested number
of bytes from/to the requested locations WILL NOT corrupt memory in the
opinion of solidity or other subsequent read/write operations.</p>
<pre><code class="language-solidity">function unsafeCopyBytesTo(Pointer sourceCursor, Pointer targetCursor, uint256 length) internal pure;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>sourceCursor</code></td><td><code>Pointer</code></td><td>The starting pointer to read from.</td></tr>
<tr><td><code>targetCursor</code></td><td><code>Pointer</code></td><td>The starting pointer to write to.</td></tr>
<tr><td><code>length</code></td><td><code>uint256</code></td><td>The number of bytes to read/write.</td></tr>
</tbody></table>
</div>
<h3 id="unsafecopywordsto"><a class="header" href="#unsafecopywordsto">unsafeCopyWordsTo</a></h3>
<p>Copies <code>length</code> <code>uint256</code> values starting from <code>source</code> to <code>target</code>
with NO attempt to check that this is safe to do so. The caller MUST
ensure that there exists allocated memory at <code>target</code> in which it is
safe and appropriate to copy <code>length * 32</code> bytes to. Anything that was
already written to memory at <code>[target:target+(length * 32 bytes)]</code>
will be overwritten.
There is no return value as memory is modified directly.</p>
<pre><code class="language-solidity">function unsafeCopyWordsTo(Pointer source, Pointer target, uint256 length) internal pure;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>source</code></td><td><code>Pointer</code></td><td>The starting position in memory that data will be copied from.</td></tr>
<tr><td><code>target</code></td><td><code>Pointer</code></td><td>The starting position in memory that data will be copied to.</td></tr>
<tr><td><code>length</code></td><td><code>uint256</code></td><td>The number of 32 byte (i.e. <code>uint256</code>) words that will be copied.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="libmemory"><a class="header" href="#libmemory">LibMemory</a></h1>
<p><a href="https://github.com/rainprotocol/rain.solmem/blob/7b2f04d6e0d7d4573e6b0a17bd9c7b84a7fde05f/src/lib/LibMemory.sol">Git Source</a></p>
<h2 id="functions-2"><a class="header" href="#functions-2">Functions</a></h2>
<h3 id="memoryisaligned"><a class="header" href="#memoryisaligned">memoryIsAligned</a></h3>
<p>Returns true if the free memory pointer is pointing at a multiple of 32
bytes, false otherwise. If all memory allocations are handled by Solidity
then this will always be true, but assembly blocks can violate this, so
this is a useful tool to test compliance of a custom assembly block with
the solidity allocator.</p>
<pre><code class="language-solidity">function memoryIsAligned() internal pure returns (bool isAligned);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>isAligned</code></td><td><code>bool</code></td><td>true if the memory is currently aligned to 32 bytes.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="pointer"><a class="header" href="#pointer">Pointer</a></h1>
<p><a href="https://github.com/rainprotocol/rain.solmem/blob/7b2f04d6e0d7d4573e6b0a17bd9c7b84a7fde05f/src/lib/LibPointer.sol">Git Source</a></p>
<p>A pointer to a location in memory. This is a <code>uint256</code> to save gas on low
level operations on the evm stack. These same low level operations typically
WILL NOT check for overflow or underflow, so all pointer logic MUST ensure
that reads, writes and movements are not out of bounds.</p>
<pre><code class="language-solidity">type Pointer is uint256;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libpointer"><a class="header" href="#libpointer">LibPointer</a></h1>
<p><a href="https://github.com/rainprotocol/rain.solmem/blob/7b2f04d6e0d7d4573e6b0a17bd9c7b84a7fde05f/src/lib/LibPointer.sol">Git Source</a></p>
<h2 id="functions-3"><a class="header" href="#functions-3">Functions</a></h2>
<h3 id="unsafeasbytes"><a class="header" href="#unsafeasbytes">unsafeAsBytes</a></h3>
<p>Cast a <code>Pointer</code> to <code>bytes</code> without modification or any safety checks.
The caller MUST ensure the pointer is to a valid region of memory for
some <code>bytes</code>.</p>
<pre><code class="language-solidity">function unsafeAsBytes(Pointer pointer) internal pure returns (bytes memory data);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The pointer to cast to <code>bytes</code>.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>data</code></td><td><code>bytes</code></td><td>The cast <code>bytes</code>.</td></tr>
</tbody></table>
</div>
<h3 id="unsafeaddbytes"><a class="header" href="#unsafeaddbytes">unsafeAddBytes</a></h3>
<p>Increase some pointer by a number of bytes.
This is UNSAFE because it can silently overflow or point beyond some
data structure. The caller MUST ensure that this is a safe operation.
Note that moving a pointer by some bytes offset is likely to unalign it
with the 32 byte increments of the Solidity allocator.</p>
<pre><code class="language-solidity">function unsafeAddBytes(Pointer pointer, uint256 length) internal pure returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The pointer to increase by <code>length</code>.</td></tr>
<tr><td><code>length</code></td><td><code>uint256</code></td><td>The number of bytes to increase the pointer by.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The increased pointer.</td></tr>
</tbody></table>
</div>
<h3 id="unsafeaddword"><a class="header" href="#unsafeaddword">unsafeAddWord</a></h3>
<p>Increase some pointer by a single 32 byte word.
This is UNSAFE because it can silently overflow or point beyond some
data structure. The caller MUST ensure that this is a safe operation.
If the original pointer is aligned to the Solidity allocator it will be
aligned after the movement.</p>
<pre><code class="language-solidity">function unsafeAddWord(Pointer pointer) internal pure returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The pointer to increase by a single word.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The increased pointer.</td></tr>
</tbody></table>
</div>
<h3 id="unsafeaddwords"><a class="header" href="#unsafeaddwords">unsafeAddWords</a></h3>
<p>Increase some pointer by multiple 32 byte words.
This is UNSAFE because it can silently overflow or point beyond some
data structure. The caller MUST ensure that this is a safe operation.
If the original pointer is aligned to the Solidity allocator it will be
aligned after the movement.</p>
<pre><code class="language-solidity">function unsafeAddWords(Pointer pointer, uint256 words) internal pure returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The pointer to increase.</td></tr>
<tr><td><code>words</code></td><td><code>uint256</code></td><td>The number of words to increase the pointer by.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The increased pointer.</td></tr>
</tbody></table>
</div>
<h3 id="unsafesubword"><a class="header" href="#unsafesubword">unsafeSubWord</a></h3>
<p>Decrease some pointer by a single 32 byte word.
This is UNSAFE because it can silently underflow or point below some
data structure. The caller MUST ensure that this is a safe operation.
If the original pointer is aligned to the Solidity allocator it will be
aligned after the movement.</p>
<pre><code class="language-solidity">function unsafeSubWord(Pointer pointer) internal pure returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The pointer to decrease by a single word.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The decreased pointer.</td></tr>
</tbody></table>
</div>
<h3 id="unsafesubwords"><a class="header" href="#unsafesubwords">unsafeSubWords</a></h3>
<p>Decrease some pointer by multiple 32 byte words.
This is UNSAFE because it can silently underflow or point below some
data structure. The caller MUST ensure that this is a safe operation.
If the original pointer is aligned to the Solidity allocator it will be
aligned after the movement.</p>
<pre><code class="language-solidity">function unsafeSubWords(Pointer pointer, uint256 words) internal pure returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The pointer to decrease.</td></tr>
<tr><td><code>words</code></td><td><code>uint256</code></td><td>The number of words to decrease the pointer by.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The decreased pointer.</td></tr>
</tbody></table>
</div>
<h3 id="unsafereadword"><a class="header" href="#unsafereadword">unsafeReadWord</a></h3>
<p>Read the word at the pointer.
This is UNSAFE because it can read outside any particular data stucture
or even beyond allocated memory. The caller MUST ensure that this is a
safe operation.</p>
<pre><code class="language-solidity">function unsafeReadWord(Pointer pointer) internal pure returns (uint256 word);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>Pointer to read the word at.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>word</code></td><td><code>uint256</code></td><td>The word read from the pointer.</td></tr>
</tbody></table>
</div>
<h3 id="unsafewriteword"><a class="header" href="#unsafewriteword">unsafeWriteWord</a></h3>
<p>Write a word at the pointer.
This is UNSAFE because it can write outside any particular data stucture
or even beyond allocated memory. The caller MUST ensure that this is a
safe operation.</p>
<pre><code class="language-solidity">function unsafeWriteWord(Pointer pointer, uint256 word) internal pure;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>Pointer to write the word at.</td></tr>
<tr><td><code>word</code></td><td><code>uint256</code></td><td>The word to write.</td></tr>
</tbody></table>
</div>
<h3 id="allocatedmemorypointer"><a class="header" href="#allocatedmemorypointer">allocatedMemoryPointer</a></h3>
<p>Get the pointer to the end of all allocated memory.
As per Solidity docs, there is no guarantee that the region of memory
beyond this pointer is zeroed out, as assembly MAY write beyond allocated
memory for temporary use if the scratch space is insufficient.</p>
<pre><code class="language-solidity">function allocatedMemoryPointer() internal pure returns (Pointer pointer);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The pointer to the end of all allocated memory.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="unalignedstackpointer"><a class="header" href="#unalignedstackpointer">UnalignedStackPointer</a></h1>
<p><a href="https://github.com/rainprotocol/rain.solmem/blob/7b2f04d6e0d7d4573e6b0a17bd9c7b84a7fde05f/src/lib/LibStackPointer.sol">Git Source</a></p>
<p>Throws if a stack pointer is not aligned to 32 bytes.</p>
<pre><code class="language-solidity">error UnalignedStackPointer(Pointer pointer);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libstackpointer"><a class="header" href="#libstackpointer">LibStackPointer</a></h1>
<p><a href="https://github.com/rainprotocol/rain.solmem/blob/7b2f04d6e0d7d4573e6b0a17bd9c7b84a7fde05f/src/lib/LibStackPointer.sol">Git Source</a></p>
<p>A stack <code>Pointer</code> is still just a pointer to some memory, but we are
going to treat it like it is pointing to a stack data structure. That means
it can move &quot;up&quot; and &quot;down&quot; (increment and decrement) by <code>uint256</code> (32 bytes)
increments. Structurally a stack is a <code>uint256[]</code> but we can save a lot of
gas vs. default Solidity handling of array indexes by using assembly to
bypass runtime bounds checks on every read and write. Of course, this means
the caller is responsible for ensuring the stack reads and write are not out
of bounds.
The pointer to the bottom of a stack points at the 0th item, NOT the length
of the implied <code>uint256[]</code> and the top of a stack points AFTER the last item.
e.g. consider a <code>uint256[]</code> in memory with values <code>3 A B C</code> and assume this
starts at position <code>0</code> in memory, i.e. <code>0</code> points to value <code>3</code> for the
array length. In this case the stack bottom would be <code>Pointer.wrap(0x20)</code>
(32 bytes above 0, past the length) and the stack top would be
<code>StackPointer.wrap(0x80)</code> (96 bytes above the stack bottom).
Most of the functions in this library are equivalent to each other via
composition, i.e. everything could be achieved with just <code>up</code>, <code>down</code>,
<code>pop</code>, <code>push</code>, <code>peek</code>. The reason there is so much overloaded/duplicated
logic is that the Solidity compiler seems to fail at inlining equivalent
logic quite a lot. Perhaps once the IR compilation of Solidity is better
supported by tooling etc. we could remove a lot of this duplication as the
compiler itself would handle the optimisations.</p>
<h2 id="functions-4"><a class="header" href="#functions-4">Functions</a></h2>
<h3 id="unsafepeek"><a class="header" href="#unsafepeek">unsafePeek</a></h3>
<p>Read the word immediately below the given stack pointer.
Treats the given pointer as a pointer to the top of the stack, so <code>peek</code>
reads the word below the pointer.
https://en.wikipedia.org/wiki/Peek_(data_type_operation)
The caller MUST ensure this read is not out of bounds, e.g. a <code>peek</code> to
<code>0</code> will underflow (and exhaust gas attempting to read).</p>
<pre><code class="language-solidity">function unsafePeek(Pointer pointer) internal pure returns (uint256 word);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>Pointer to the top of the stack to read below.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>word</code></td><td><code>uint256</code></td><td>The word that was read.</td></tr>
</tbody></table>
</div>
<h3 id="unsafepeek2"><a class="header" href="#unsafepeek2">unsafePeek2</a></h3>
<p>Peeks 2 words from the top of the stack.
Same as <code>unsafePeek</code> but returns 2 words instead of 1.</p>
<pre><code class="language-solidity">function unsafePeek2(Pointer pointer) internal pure returns (uint256 lower, uint256 upper);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The stack top to peek below.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>lower</code></td><td><code>uint256</code></td><td>The lower of the two words read.</td></tr>
<tr><td><code>upper</code></td><td><code>uint256</code></td><td>The upper of the two words read.</td></tr>
</tbody></table>
</div>
<h3 id="unsafepop"><a class="header" href="#unsafepop">unsafePop</a></h3>
<p>Pops the word from the top of the stack.
Treats the given pointer as a pointer to the top of the stack, so <code>pop</code>
reads the word below the pointer. The popped pointer is returned
alongside the read word.
https://en.wikipedia.org/wiki/Stack_(abstract_data_type)
The caller MUST ensure the pop will not result in an out of bounds read.</p>
<pre><code class="language-solidity">function unsafePop(Pointer pointer) internal pure returns (Pointer pointerAfter, uint256 word);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>Pointer to the top of the stack to read below.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointerAfter</code></td><td><code>Pointer</code></td><td>Pointer after the pop.</td></tr>
<tr><td><code>word</code></td><td><code>uint256</code></td><td>The word that was read.</td></tr>
</tbody></table>
</div>
<h3 id="unsafepush"><a class="header" href="#unsafepush">unsafePush</a></h3>
<p>Pushes a word to the top of the stack.
Treats the given pointer as a pointer to the top of the stack, so <code>push</code>
writes a word at the pointer. The pushed pointer is returned.
https://en.wikipedia.org/wiki/Stack_(abstract_data_type)
The caller MUST ensure the push will not result in an out of bounds
write.</p>
<pre><code class="language-solidity">function unsafePush(Pointer pointer, uint256 word) internal pure returns (Pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The stack pointer to write at.</td></tr>
<tr><td><code>word</code></td><td><code>uint256</code></td><td>The value to write.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Pointer</code></td><td>The stack pointer above where <code>word</code> was written to.</td></tr>
</tbody></table>
</div>
<h3 id="unsafelist"><a class="header" href="#unsafelist">unsafeList</a></h3>
<p>Returns <code>length</code> values from the stack as an array without allocating
new memory. As arrays always start with their length, this requires
writing the length value to the stack below the array values. The value
that is overwritten in the process is also returned so that data is not
lost. For example, imagine a stack <code>[ A B C D ]</code> and we list 2 values.
This will write the stack to look like <code>[ A 2 C D ]</code> and return both <code>B</code>
and a pointer to <code>2</code> represented as a <code>uint256[]</code>.
The returned array is ONLY valid for as long as the stack DOES NOT move
back into its memory. As soon as the stack moves up again and writes into
the array it will be corrupt. The caller MUST ensure that it does not
read from the returned array after it has been corrupted by subsequent
stack writes.</p>
<pre><code class="language-solidity">function unsafeList(Pointer pointer, uint256 length) internal pure returns (uint256 head, uint256[] memory tail);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The stack pointer to read the values below into an array.</td></tr>
<tr><td><code>length</code></td><td><code>uint256</code></td><td>The number of values to include in the returned array.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>head</code></td><td><code>uint256</code></td><td>The value that was overwritten with the length.</td></tr>
<tr><td><code>tail</code></td><td><code>uint256[]</code></td><td>The array constructed from the stack memory.</td></tr>
</tbody></table>
</div>
<h3 id="toindexsigned"><a class="header" href="#toindexsigned">toIndexSigned</a></h3>
<p>Convert two stack pointer values to a single stack index. A stack index
is the distance in 32 byte increments between two stack pointers. The
calculations require the two stack pointers are aligned. If the pointers
are not aligned, the function will revert.</p>
<pre><code class="language-solidity">function toIndexSigned(Pointer lower, Pointer upper) internal pure returns (int256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>lower</code></td><td><code>Pointer</code></td><td>The lower of the two values.</td></tr>
<tr><td><code>upper</code></td><td><code>Pointer</code></td><td>The higher of the two values.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>int256</code></td><td>The stack index as 32 byte words distance between the top and bottom. Negative if <code>lower</code> is above <code>upper</code>.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="missingsentinel"><a class="header" href="#missingsentinel">MissingSentinel</a></h1>
<p><a href="https://github.com/rainprotocol/rain.solmem/blob/7b2f04d6e0d7d4573e6b0a17bd9c7b84a7fde05f/src/lib/LibStackSentinel.sol">Git Source</a></p>
<p>Thrown when the sentinel cannot be found. This can be because the sentinel
was not in stack, but also if the upper pointer is below the lower, or the
sentinel is in the stack but not aligned with the tuples size.</p>
<pre><code class="language-solidity">error MissingSentinel(Sentinel sentinel);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sentinel"><a class="header" href="#sentinel">Sentinel</a></h1>
<p><a href="https://github.com/rainprotocol/rain.solmem/blob/7b2f04d6e0d7d4573e6b0a17bd9c7b84a7fde05f/src/lib/LibStackSentinel.sol">Git Source</a></p>
<blockquote>
<p>In computer programming, a sentinel value (also referred to as a flag
value, trip value, rogue value, signal value, or dummy data)[1] is a
special value in the context of an algorithm which uses its presence as a
condition of termination, typically in a loop or recursive algorithm.</p>
<p>The sentinel value is a form of in-band data that makes it possible to
detect the end of the data when no out-of-band data (such as an explicit
size indication) is provided. The value should be selected in such a way
that it is guaranteed to be distinct from all legal data values since
otherwise, the presence of such values would prematurely signal the end of
the data (the semipredicate problem).</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Sentinel_value">Wikipedia</a></li>
</ul>
</blockquote>
<pre><code class="language-solidity">type Sentinel is uint256;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libstacksentinel"><a class="header" href="#libstacksentinel">LibStackSentinel</a></h1>
<p><a href="https://github.com/rainprotocol/rain.solmem/blob/7b2f04d6e0d7d4573e6b0a17bd9c7b84a7fde05f/src/lib/LibStackSentinel.sol">Git Source</a></p>
<p>Rainlang has no dynamic list data type as every stack item MUST be explicit
in the structure of the code itself. While it would be possible for users to
manually code length prefixes into the stack, this would be error prone and
generally hostile to the overall DX. Instead we can allow sentinels as an
option that is merely awkward rather than downright pathological.
Rainlang authors can use a single sentinel value that is constant across all
their expressions rather than a calculated length prefix. This value can even
be aliased in onchain metadata and referenced by name for ease of use. The
calling contract defines and consumes sentinels, so the expression author
does not need to be aware of or have control over any subtleties in choice of
sentinel.
The main tradeoffs for sentinel terminated lists on a stack are similar to
null-terminated strings,
as per <a href="https://en.wikipedia.org/wiki/Null-terminated_string">Wikipedia</a></p>
<blockquote>
<p>While simple to implement, this representation has been prone to errors and
performance problems.
This library attempts to mitigate potential implementation errors with a
standard implementation that has been fuzzed and optimized for building lists
of tuples (and therefore lists of structs via. a direct type cast). The main
implementation issues in null-terminated strings are avoided:</p>
</blockquote>
<ul>
<li>Using any sentinel value other than <code>0</code>, such as the hash of some well
known string, will avoid misinterpreting unallocated memory as a sentinel.</li>
<li>Any underflows manifest as either a &quot;missing sentinel&quot; or infinite loop,
which will revert either way due to an explicit check or gas limits.</li>
<li>Given that a sentinel is <code>uint256</code> it is possible to construct a value that
is very unlikely to collide with real values in the implementation domain.</li>
<li>Well behaved integrity checks will ensure the memory for the sentinel is
allocated as any other stack item.
Sadly there is no way to avoid the O(n) performance overhead of searching for
a sentinel vs. O(1) of reading a length prefix directly. This is somewhat
mitigated by the nature of a hand-written stack being small in
computing terms, and that each item being iterated over is an entire struct
rather than individual stack values. Assembly is used to keep the looping
overhead to a minimum.</li>
</ul>
<h2 id="functions-5"><a class="header" href="#functions-5">Functions</a></h2>
<h3 id="consumesentineltuples"><a class="header" href="#consumesentineltuples">consumeSentinelTuples</a></h3>
<p>Given two stack pointers that bound a stack build an array of <code>n</code> item
tuples above the given sentinel value. The sentinel will be skipped and
a pointer below it returned alongside the tuples list.
The tuples can be cast (via assembly) to structs.
The caller MUST consider the region of memory consumed for the structs as
mutated/truncated/deallocated and reallocated insitu to the tuples.
The sentinel MUST be chosen to have a negligible chance of colliding with
a real value in the array, otherwise an intended array item will be
interpreted as a sentinel.
If the sentinel is absent in the stack this WILL REVERT. The intent is
to represent dynamic length arrays without forcing expression authors to
calculate lengths on the stack. If the expression author wants to model
an empty/optional/absent value they MAY provided a sentinel for a zero
length array and the calling contract SHOULD handle this.
If <code>lower</code> is smaller than <code>n</code> it is possible that this will underflow
which will result in the evm immediately running out of gas as it
attempts to loop from infinity. There is no explicit underflow check but
there is no way to underflow without reverting due to gas.</p>
<pre><code class="language-solidity">function consumeSentinelTuples(Pointer lower, Pointer upper, Sentinel sentinel, uint256 n)
    internal
    pure
    returns (Pointer sentinelPointer, Pointer tuplesPointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>lower</code></td><td><code>Pointer</code></td><td>Pointer to the bottom of the stack range.</td></tr>
<tr><td><code>upper</code></td><td><code>Pointer</code></td><td>Pointer to the top of the stack range.</td></tr>
<tr><td><code>sentinel</code></td><td><code>Sentinel</code></td><td>The value to expect as the sentinel. MUST be present in the stack or <code>consumeSentinel</code> will revert. MUST NOT collide with valid stack items (or be cryptographically improbable to do so).</td></tr>
<tr><td><code>n</code></td><td><code>uint256</code></td><td>The number of items per tuple.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>sentinelPointer</code></td><td><code>Pointer</code></td><td>Pointer to the sentinel that was found. A missing sentinel WILL REVERT.</td></tr>
<tr><td><code>tuplesPointer</code></td><td><code>Pointer</code></td><td>Pointer to the n-item tuples array that was built.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="outofboundstruncate"><a class="header" href="#outofboundstruncate">OutOfBoundsTruncate</a></h1>
<p><a href="https://github.com/rainprotocol/rain.solmem/blob/7b2f04d6e0d7d4573e6b0a17bd9c7b84a7fde05f/src/lib/LibUint256Array.sol">Git Source</a></p>
<p>Thrown if a truncated length is longer than the array being truncated. It is
not possible to truncate something and increase its length as the memory
region after the array MAY be allocated for something else already.</p>
<pre><code class="language-solidity">error OutOfBoundsTruncate(uint256 arrayLength, uint256 truncatedLength);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libuint256array"><a class="header" href="#libuint256array">LibUint256Array</a></h1>
<p><a href="https://github.com/rainprotocol/rain.solmem/blob/7b2f04d6e0d7d4573e6b0a17bd9c7b84a7fde05f/src/lib/LibUint256Array.sol">Git Source</a></p>
<p>Things we want to do carefully and efficiently with uint256 arrays
that Solidity doesn't give us native tools for.</p>
<h2 id="functions-6"><a class="header" href="#functions-6">Functions</a></h2>
<h3 id="startpointer-1"><a class="header" href="#startpointer-1">startPointer</a></h3>
<p>Pointer to the start (length prefix) of a <code>uint256[]</code>.</p>
<pre><code class="language-solidity">function startPointer(uint256[] memory array) internal pure returns (Pointer pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>array</code></td><td><code>uint256[]</code></td><td>The array to get the start pointer of.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The pointer to the start of <code>array</code>.</td></tr>
</tbody></table>
</div>
<h3 id="datapointer-1"><a class="header" href="#datapointer-1">dataPointer</a></h3>
<p>Pointer to the data of a <code>uint256[]</code> NOT the length prefix.</p>
<pre><code class="language-solidity">function dataPointer(uint256[] memory array) internal pure returns (Pointer pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>array</code></td><td><code>uint256[]</code></td><td>The array to get the data pointer of.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The pointer to the data of <code>array</code>.</td></tr>
</tbody></table>
</div>
<h3 id="endpointer"><a class="header" href="#endpointer">endPointer</a></h3>
<p>Pointer to the end of the allocated memory of an array.</p>
<pre><code class="language-solidity">function endPointer(uint256[] memory array) internal pure returns (Pointer pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>array</code></td><td><code>uint256[]</code></td><td>The array to get the end pointer of.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The pointer to the end of <code>array</code>.</td></tr>
</tbody></table>
</div>
<h3 id="unsafeasuint256array"><a class="header" href="#unsafeasuint256array">unsafeAsUint256Array</a></h3>
<p>Cast a <code>Pointer</code> to <code>uint256[]</code> without modification or safety checks.
The caller MUST ensure the pointer is to a valid region of memory for
some <code>uint256[]</code>.</p>
<pre><code class="language-solidity">function unsafeAsUint256Array(Pointer pointer) internal pure returns (uint256[] memory array);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The pointer to cast to <code>uint256[]</code>.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>array</code></td><td><code>uint256[]</code></td><td>The cast <code>uint256[]</code>.</td></tr>
</tbody></table>
</div>
<h3 id="arrayfrom"><a class="header" href="#arrayfrom">arrayFrom</a></h3>
<p>Building arrays from literal components is a common task that introduces
boilerplate that is either inefficient or error prone.</p>
<pre><code class="language-solidity">function arrayFrom(uint256 a) internal pure returns (uint256[] memory array);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>a</code></td><td><code>uint256</code></td><td>A single integer to build an array around.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>array</code></td><td><code>uint256[]</code></td><td>The newly allocated array including <code>a</code> as a single item.</td></tr>
</tbody></table>
</div>
<h3 id="arrayfrom-1"><a class="header" href="#arrayfrom-1">arrayFrom</a></h3>
<p>Building arrays from literal components is a common task that introduces
boilerplate that is either inefficient or error prone.</p>
<pre><code class="language-solidity">function arrayFrom(uint256 a, uint256 b) internal pure returns (uint256[] memory array);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>a</code></td><td><code>uint256</code></td><td>The first integer to build an array around.</td></tr>
<tr><td><code>b</code></td><td><code>uint256</code></td><td>The second integer to build an array around.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>array</code></td><td><code>uint256[]</code></td><td>The newly allocated array including <code>a</code> and <code>b</code> as the only items.</td></tr>
</tbody></table>
</div>
<h3 id="arrayfrom-2"><a class="header" href="#arrayfrom-2">arrayFrom</a></h3>
<p>Building arrays from literal components is a common task that introduces
boilerplate that is either inefficient or error prone.</p>
<pre><code class="language-solidity">function arrayFrom(uint256 a, uint256 b, uint256 c) internal pure returns (uint256[] memory array);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>a</code></td><td><code>uint256</code></td><td>The first integer to build an array around.</td></tr>
<tr><td><code>b</code></td><td><code>uint256</code></td><td>The second integer to build an array around.</td></tr>
<tr><td><code>c</code></td><td><code>uint256</code></td><td>The third integer to build an array around.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>array</code></td><td><code>uint256[]</code></td><td>The newly allocated array including <code>a</code>, <code>b</code> and <code>c</code> as the only items.</td></tr>
</tbody></table>
</div>
<h3 id="arrayfrom-3"><a class="header" href="#arrayfrom-3">arrayFrom</a></h3>
<p>Building arrays from literal components is a common task that introduces
boilerplate that is either inefficient or error prone.</p>
<pre><code class="language-solidity">function arrayFrom(uint256 a, uint256 b, uint256 c, uint256 d) internal pure returns (uint256[] memory array);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>a</code></td><td><code>uint256</code></td><td>The first integer to build an array around.</td></tr>
<tr><td><code>b</code></td><td><code>uint256</code></td><td>The second integer to build an array around.</td></tr>
<tr><td><code>c</code></td><td><code>uint256</code></td><td>The third integer to build an array around.</td></tr>
<tr><td><code>d</code></td><td><code>uint256</code></td><td>The fourth integer to build an array around.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>array</code></td><td><code>uint256[]</code></td><td>The newly allocated array including <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code> as the only items.</td></tr>
</tbody></table>
</div>
<h3 id="arrayfrom-4"><a class="header" href="#arrayfrom-4">arrayFrom</a></h3>
<p>Building arrays from literal components is a common task that introduces
boilerplate that is either inefficient or error prone.</p>
<pre><code class="language-solidity">function arrayFrom(uint256 a, uint256 b, uint256 c, uint256 d, uint256 e)
    internal
    pure
    returns (uint256[] memory array);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>a</code></td><td><code>uint256</code></td><td>The first integer to build an array around.</td></tr>
<tr><td><code>b</code></td><td><code>uint256</code></td><td>The second integer to build an array around.</td></tr>
<tr><td><code>c</code></td><td><code>uint256</code></td><td>The third integer to build an array around.</td></tr>
<tr><td><code>d</code></td><td><code>uint256</code></td><td>The fourth integer to build an array around.</td></tr>
<tr><td><code>e</code></td><td><code>uint256</code></td><td>The fifth integer to build an array around.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>array</code></td><td><code>uint256[]</code></td><td>The newly allocated array including <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> and <code>e</code> as the only items.</td></tr>
</tbody></table>
</div>
<h3 id="arrayfrom-5"><a class="header" href="#arrayfrom-5">arrayFrom</a></h3>
<p>Building arrays from literal components is a common task that introduces
boilerplate that is either inefficient or error prone.</p>
<pre><code class="language-solidity">function arrayFrom(uint256 a, uint256 b, uint256 c, uint256 d, uint256 e, uint256 f)
    internal
    pure
    returns (uint256[] memory array);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>a</code></td><td><code>uint256</code></td><td>The first integer to build an array around.</td></tr>
<tr><td><code>b</code></td><td><code>uint256</code></td><td>The second integer to build an array around.</td></tr>
<tr><td><code>c</code></td><td><code>uint256</code></td><td>The third integer to build an array around.</td></tr>
<tr><td><code>d</code></td><td><code>uint256</code></td><td>The fourth integer to build an array around.</td></tr>
<tr><td><code>e</code></td><td><code>uint256</code></td><td>The fifth integer to build an array around.</td></tr>
<tr><td><code>f</code></td><td><code>uint256</code></td><td>The sixth integer to build an array around.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>array</code></td><td><code>uint256[]</code></td><td>The newly allocated array including <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code> and <code>f</code> as the only items.</td></tr>
</tbody></table>
</div>
<h3 id="arrayfrom-6"><a class="header" href="#arrayfrom-6">arrayFrom</a></h3>
<p>Building arrays from literal components is a common task that introduces
boilerplate that is either inefficient or error prone.</p>
<pre><code class="language-solidity">function arrayFrom(uint256 a, uint256[] memory tail) internal pure returns (uint256[] memory array);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>a</code></td><td><code>uint256</code></td><td>The head of the new array.</td></tr>
<tr><td><code>tail</code></td><td><code>uint256[]</code></td><td>The tail of the new array.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>array</code></td><td><code>uint256[]</code></td><td>The new array.</td></tr>
</tbody></table>
</div>
<h3 id="arrayfrom-7"><a class="header" href="#arrayfrom-7">arrayFrom</a></h3>
<p>Building arrays from literal components is a common task that introduces
boilerplate that is either inefficient or error prone.</p>
<pre><code class="language-solidity">function arrayFrom(uint256 a, uint256 b, uint256[] memory tail) internal pure returns (uint256[] memory array);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>a</code></td><td><code>uint256</code></td><td>The first item of the new array.</td></tr>
<tr><td><code>b</code></td><td><code>uint256</code></td><td>The second item of the new array.</td></tr>
<tr><td><code>tail</code></td><td><code>uint256[]</code></td><td>The tail of the new array.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>array</code></td><td><code>uint256[]</code></td><td>The new array.</td></tr>
</tbody></table>
</div>
<h3 id="truncate-1"><a class="header" href="#truncate-1">truncate</a></h3>
<p>Solidity provides no way to change the length of in-memory arrays but
it also does not deallocate memory ever. It is always safe to shrink an
array that has already been allocated, with the caveat that the
truncated items will effectively become inaccessible regions of memory.
That is to say, we deliberately &quot;leak&quot; the truncated items, but that is
no worse than Solidity's native behaviour of leaking everything always.
The array is MUTATED in place so there is no return value and there is
no new allocation or copying of data either.</p>
<pre><code class="language-solidity">function truncate(uint256[] memory array, uint256 newLength) internal pure;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>array</code></td><td><code>uint256[]</code></td><td>The array to truncate.</td></tr>
<tr><td><code>newLength</code></td><td><code>uint256</code></td><td>The new length of the array after truncation.</td></tr>
</tbody></table>
</div>
<h3 id="unsafeextend"><a class="header" href="#unsafeextend">unsafeExtend</a></h3>
<p>Extends <code>base_</code> with <code>extend_</code> by allocating only an additional
<code>extend_.length</code> words onto <code>base_</code> and copying only <code>extend_</code> if
possible. If <code>base_</code> is large this MAY be significantly more efficient
than allocating <code>base_.length + extend_.length</code> for an entirely new array
and copying both <code>base_</code> and <code>extend_</code> into the new array one item at a
time in Solidity.
The efficient version of extension is only possible if the free memory
pointer sits at the end of the base array at the moment of extension. If
there is allocated memory after the end of base then extension will
require copying both the base and extend arays to a new region of memory.
The caller is responsible for optimising code paths to avoid additional
allocations.
This function is UNSAFE because the base array IS MUTATED DIRECTLY by
some code paths AND THE FINAL RETURN ARRAY MAY POINT TO THE SAME REGION
OF MEMORY. It is NOT POSSIBLE to reliably see this behaviour from the
caller in all cases as the Solidity compiler optimisations may switch the
caller between the allocating and non-allocating logic due to subtle
optimisation reasons. To use this function safely THE CALLER MUST NOT USE
THE BASE ARRAY AND MUST USE THE RETURNED ARRAY ONLY. It is safe to use
the extend array after calling this function as it is never mutated, it
is only copied from.</p>
<pre><code class="language-solidity">function unsafeExtend(uint256[] memory b, uint256[] memory e) internal pure returns (uint256[] memory extended);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>b</code></td><td><code>uint256[]</code></td><td>The base integer array that will be extended by <code>e</code>.</td></tr>
<tr><td><code>e</code></td><td><code>uint256[]</code></td><td>The extend integer array that extends <code>b</code>.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>extended</code></td><td><code>uint256[]</code></td><td>The extended array of <code>b</code> extended by <code>e</code>.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="libuint256matrix"><a class="header" href="#libuint256matrix">LibUint256Matrix</a></h1>
<p><a href="https://github.com/rainprotocol/rain.solmem/blob/7b2f04d6e0d7d4573e6b0a17bd9c7b84a7fde05f/src/lib/LibUint256Matrix.sol">Git Source</a></p>
<h2 id="functions-7"><a class="header" href="#functions-7">Functions</a></h2>
<h3 id="startpointer-2"><a class="header" href="#startpointer-2">startPointer</a></h3>
<p>Pointer to the start (length prefix) of a <code>uint256[][]</code>.</p>
<pre><code class="language-solidity">function startPointer(uint256[][] memory matrix) internal pure returns (Pointer pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>matrix</code></td><td><code>uint256[][]</code></td><td>The matrix to get the start pointer of.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The pointer to the start of <code>matrix</code>.</td></tr>
</tbody></table>
</div>
<h3 id="datapointer-2"><a class="header" href="#datapointer-2">dataPointer</a></h3>
<p>Pointer to the data of a <code>uint256[][]</code> NOT the length prefix.
Note that the data of a <code>uint256[][]</code> is <em>references</em> to the <code>uint256[]</code>
start pointers and does NOT include the arrays themselves.</p>
<pre><code class="language-solidity">function dataPointer(uint256[][] memory matrix) internal pure returns (Pointer pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>matrix</code></td><td><code>uint256[][]</code></td><td>The matrix to get the data pointer of.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The pointer to the data of <code>matrix</code>.</td></tr>
</tbody></table>
</div>
<h3 id="endpointer-1"><a class="header" href="#endpointer-1">endPointer</a></h3>
<p>Pointer to the end of the allocated memory of a matrix.
Note that the data of a <code>uint256[][]</code> is <em>references</em> to the <code>uint256[]</code>
start pointers and does NOT include the arrays themselves.</p>
<pre><code class="language-solidity">function endPointer(uint256[][] memory matrix) internal pure returns (Pointer pointer);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>matrix</code></td><td><code>uint256[][]</code></td><td>The matrix to get the end pointer of.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The pointer to the end of <code>matrix</code>.</td></tr>
</tbody></table>
</div>
<h3 id="unsafeasuint256matrix"><a class="header" href="#unsafeasuint256matrix">unsafeAsUint256Matrix</a></h3>
<p>Cast a <code>Pointer</code> to <code>uint256[][]</code> without modification or safety checks.
The caller MUST ensure the pointer is to a valid region of memory for
some <code>uint256[][]</code>.</p>
<pre><code class="language-solidity">function unsafeAsUint256Matrix(Pointer pointer) internal pure returns (uint256[][] memory matrix);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pointer</code></td><td><code>Pointer</code></td><td>The pointer to cast to <code>uint256[][]</code>.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>matrix</code></td><td><code>uint256[][]</code></td><td>The cast <code>uint256[][]</code>.</td></tr>
</tbody></table>
</div>
<h3 id="matrixfrom"><a class="header" href="#matrixfrom">matrixFrom</a></h3>
<p>2-dimensional analogue of <code>arrayFrom</code>. Takes a 1-dimensional array and
coerces it to a 2-dimensional matrix where the first and only item in the
matrix is the 1-dimensional array.</p>
<pre><code class="language-solidity">function matrixFrom(uint256[] memory a) internal pure returns (uint256[][] memory matrix);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>a</code></td><td><code>uint256[]</code></td><td>The 1-dimensional array to include in the matrix.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>matrix</code></td><td><code>uint256[][]</code></td><td>The 2-dimensional matrix containing <code>a</code>.</td></tr>
</tbody></table>
</div>
<h3 id="matrixfrom-1"><a class="header" href="#matrixfrom-1">matrixFrom</a></h3>
<p>2-dimensional analogue of <code>arrayFrom</code>. Takes 1-dimensional arrays and
coerces them to a 2-dimensional matrix where items in the matrix are the
1-dimensional arrays.</p>
<pre><code class="language-solidity">function matrixFrom(uint256[] memory a, uint256[] memory b) internal pure returns (uint256[][] memory matrix);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>a</code></td><td><code>uint256[]</code></td><td>The 1-dimensional array to include in the matrix.</td></tr>
<tr><td><code>b</code></td><td><code>uint256[]</code></td><td>Second 1-dimensional array to include in the matrix.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>matrix</code></td><td><code>uint256[][]</code></td><td>The 2-dimensional matrix containing <code>a</code> and <code>b</code>.</td></tr>
</tbody></table>
</div>
<h3 id="matrixfrom-2"><a class="header" href="#matrixfrom-2">matrixFrom</a></h3>
<p>2-dimensional analogue of <code>arrayFrom</code>. Takes 1-dimensional arrays and
coerces them to a 2-dimensional matrix where items in the matrix are the
1-dimensional arrays.</p>
<pre><code class="language-solidity">function matrixFrom(uint256[] memory a, uint256[] memory b, uint256[] memory c)
    internal
    pure
    returns (uint256[][] memory matrix);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>a</code></td><td><code>uint256[]</code></td><td>The 1-dimensional array to include in the matrix.</td></tr>
<tr><td><code>b</code></td><td><code>uint256[]</code></td><td>Second 1-dimensional array to include in the matrix.</td></tr>
<tr><td><code>c</code></td><td><code>uint256[]</code></td><td>Third 1-dimensional array to include in the matrix.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>matrix</code></td><td><code>uint256[][]</code></td><td>The 2-dimensional matrix containing <code>a</code>, <code>b</code> and <code>c</code>.</td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="solidity.min.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
